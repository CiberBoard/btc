import subprocess
import time
import random
import platform
import logging
from typing import Tuple, Optional, Dict, Any, Set, List
from collections import deque
from threading import Thread

from PyQt5.QtCore import QThread, pyqtSignal

try:
    import pynvml

    PYNVML_AVAILABLE = True
except ImportError:
    PYNVML_AVAILABLE = False
    pynvml = None
    logging.getLogger('bitcoin_scanner').warning("pynvml –Ω–µ –Ω–∞–π–¥–µ–Ω. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ GPU –±—É–¥–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")

try:
    import win32process
    import win32api

    WIN32_AVAILABLE = True
except ImportError:
    WIN32_AVAILABLE = False

import config
from utils.helpers import validate_key_range, private_key_to_wif

logger = logging.getLogger('bitcoin_scanner')

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
GPU_STATUS_INITIALIZED = False
MAX_RETRY_ATTEMPTS = 100
DEFAULT_PRIORITY_CLASS = 0x00000020  # NORMAL_PRIORITY_CLASS


class OptimizedOutputReader(QThread):
    """–ß—Ç–µ–Ω–∏–µ –≤—ã–≤–æ–¥–∞ GPU –ø—Ä–æ—Ü–µ—Å—Å–∞"""
    log_message = pyqtSignal(str, str)  # message, level
    stats_update = pyqtSignal(dict)  # {'speed': float, 'checked': int}
    found_key = pyqtSignal(dict)  # key_data dict
    process_finished = pyqtSignal()

    def __init__(self, process: subprocess.Popen, parent=None):
        super().__init__(parent)
        self.process = process
        self.current_address: Optional[str] = None
        self.current_private_key: Optional[str] = None
        self.last_speed: float = 0.0
        self.last_checked: int = 0
        self._running = True

    def run(self) -> None:
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞"""
        buffer = ""
        try:
            while self._running and self.process and self.process.poll() is None:
                chunk = self._read_process_output()
                if chunk:
                    buffer = self._process_buffer(buffer + chunk)
                time.sleep(0.01)  # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è –Ω–∞–≥—Ä—É–∑–∫–∏

            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –±—É—Ñ–µ—Ä–∞
            if buffer.strip():
                self._process_remaining_buffer(buffer)

        except Exception as e:
            logger.exception("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞ GPU")
            self.log_message.emit(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞: {str(e)}", "error")
        finally:
            self.process_finished.emit()

    def _read_process_output(self) -> str:
        """–ß—Ç–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ stdout –ø—Ä–æ—Ü–µ—Å—Å–∞"""
        try:
            return self.process.stdout.read(1024) or ""
        except Exception:
            return ""

    def _process_buffer(self, buffer: str) -> str:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –±—É—Ñ–µ—Ä–∞ –≤—ã–≤–æ–¥–∞"""
        lines = buffer.split('\n')
        remaining_buffer = lines[-1]

        for line in lines[:-1]:
            if line.strip():
                self.process_line(line.strip())

        return remaining_buffer

    def _process_remaining_buffer(self, buffer: str) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –±—É—Ñ–µ—Ä–∞"""
        for line in buffer.strip().split('\n'):
            if line.strip():
                self.process_line(line.strip())

    def process_line(self, line: str) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–æ–∫–∏ –≤—ã–≤–æ–¥–∞ GPU"""
        if not line.strip():
            return

        line_lower = line.lower()

        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        if self._is_error_message(line_lower):
            self._handle_error_message(line)
        elif self._is_found_key_message(line_lower):
            self._handle_found_key_message(line)
        else:
            self._handle_normal_message(line)

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –∫–ª—é—á–µ–π
        self._process_statistics(line)
        self._process_key_finding(line)

    def _is_error_message(self, line_lower: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—à–∏–±–∫–æ–π"""
        return "–æ—à–∏–±–∫–∞" in line_lower or "error" in line_lower

    def _is_found_key_message(self, line_lower: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∞–π–¥–µ–Ω–Ω–æ–º –∫–ª—é—á–µ"""
        return "–Ω–∞–π–¥–µ–Ω –∫–ª—é—á" in line_lower or "found key" in line_lower

    def _handle_error_message(self, line: str) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ"""
        self.log_message.emit(line, "error")
        logger.error(f"GPU Error: {line}")

    def _handle_found_key_message(self, line: str) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –Ω–∞–π–¥–µ–Ω–Ω–æ–º –∫–ª—é—á–µ"""
        self.log_message.emit(line, "success")
        logger.info(f"GPU Key Found: {line}")

    def _handle_normal_message(self, line: str) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        self.log_message.emit(line, "normal")
        logger.debug(f"GPU Output: {line}")

    def _process_statistics(self, line: str) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–∑ —Å—Ç—Ä–æ–∫–∏"""
        speed_match = config.SPEED_REGEX.search(line)
        total_match = config.TOTAL_REGEX.search(line)

        if speed_match or total_match:
            speed = float(speed_match.group(1)) if speed_match else self.last_speed
            checked = int(total_match.group(1).replace(',', '')) if total_match else self.last_checked

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
            if speed_match:
                self.last_speed = speed
            if total_match:
                self.last_checked = checked

            self.stats_update.emit({'speed': speed, 'checked': checked})

    def _process_key_finding(self, line: str) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –∞–¥—Ä–µ—Å–∞ –∏ –∫–ª—é—á–∞"""
        addr_match = config.ADDR_REGEX.search(line)
        if addr_match:
            self.current_address = addr_match.group(1)

        key_match = config.KEY_REGEX.search(line)
        if key_match:
            self.current_private_key = key_match.group(1)

        if self.current_address and self.current_private_key:
            self.process_found_key()

    def process_found_key(self) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞"""
        try:
            if not self.current_private_key:
                return

            wif_key = private_key_to_wif(self.current_private_key)
            found_data = {
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'address': self.current_address,
                'hex_key': self.current_private_key,
                'wif_key': wif_key,
                'source': 'GPU'
            }
            self.found_key.emit(found_data)
            self.log_message.emit(f"üîë –ù–ê–ô–î–ï–ù –ö–õ–Æ–ß! –ê–¥—Ä–µ—Å: {self.current_address}", "success")

            # –°–±—Ä–æ—Å —Ç–µ–∫—É—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
            self.current_address = None
            self.current_private_key = None

        except Exception as e:
            logger.exception("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞")
            self.log_message.emit(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞: {str(e)}", "error")

    def stop(self) -> None:
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞"""
        self._running = False


def start_gpu_search_with_range(
        target_address: str,
        start_key: int,
        end_key: int,
        device: int,
        blocks: int,
        threads: int,
        points: int,
        priority_index: int,
        parent_window: Any
) -> Tuple[Optional[subprocess.Popen], Optional[OptimizedOutputReader]]:
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç GPU –ø–æ–∏—Å–∫ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º"""
    logger.info(f"–ó–∞–ø—É—Å–∫ GPU –ø–æ–∏—Å–∫–∞ –¥–ª—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ {hex(start_key)} - {hex(end_key)} –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ {device}")

    cmd = [
        config.CUBITCRACK_EXE,
        "-d", str(device),
        "-b", str(blocks),
        "-t", str(threads),
        "-p", str(points),
        "--keyspace", f"{hex(start_key)[2:].upper()}:{hex(end_key)[2:].upper()}",
        target_address
    ]

    # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞
    creationflags = _get_process_creation_flags(priority_index)

    try:
        logger.debug(f"–ö–æ–º–∞–Ω–¥–∞ –∑–∞–ø—É—Å–∫–∞ cuBitcrack: {' '.join(cmd)}")
        cuda_process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            bufsize=0,
            cwd=config.BASE_DIR,
            creationflags=creationflags
        )

        output_reader = OptimizedOutputReader(cuda_process)

        # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –¥–ª—è Windows
        _set_windows_process_priority(cuda_process, priority_index)

        return cuda_process, output_reader

    except Exception as e:
        logger.exception(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ cuBitcrack –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ {device}")
        return None, None


def _get_process_creation_flags(priority_index: int) -> int:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–ª–∞–≥–æ–≤ —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞"""
    if platform.system() != 'Windows':
        return 0

    priority_value = config.WINDOWS_GPU_PRIORITY_MAP.get(priority_index, DEFAULT_PRIORITY_CLASS)
    return subprocess.CREATE_NEW_PROCESS_GROUP | priority_value


def _set_windows_process_priority(process: subprocess.Popen, priority_index: int) -> None:
    """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è Windows"""
    if platform.system() != 'Windows' or not WIN32_AVAILABLE or priority_index <= 0:
        return

    try:
        priority_value = config.WINDOWS_GPU_PRIORITY_MAP.get(priority_index, DEFAULT_PRIORITY_CLASS)
        handle = win32api.OpenProcess(win32process.PROCESS_ALL_ACCESS, True, process.pid)
        win32process.SetPriorityClass(handle, priority_value)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞: {str(e)}")


def stop_gpu_search_internal(processes: List[Tuple[subprocess.Popen, OptimizedOutputReader]]) -> None:
    """–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ GPU –ø–æ–∏—Å–∫–∞"""
    logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ GPU –ø—Ä–æ—Ü–µ—Å—Å–æ–≤...")

    for process, reader in processes:
        try:
            _stop_single_process(process, reader)
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞: {str(e)}")

    processes.clear()
    logger.info("GPU –ø—Ä–æ—Ü–µ—Å—Å—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã.")


def _stop_single_process(process: subprocess.Popen, reader: OptimizedOutputReader) -> None:
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–¥–Ω–æ–≥–æ GPU –ø—Ä–æ—Ü–µ—Å—Å–∞"""
    # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞
    reader.stop()

    # –ü–æ–ø—ã—Ç–∫–∞ –º—è–≥–∫–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
    try:
        process.terminate()
        process.wait(timeout=5)
    except subprocess.TimeoutExpired:
        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
        try:
            process.kill()
        except Exception:
            pass
    except Exception:
        pass

    # –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ —á—Ç–µ–Ω–∏—è
    try:
        reader.quit()
        reader.wait(1000)
    except Exception:
        pass


def generate_gpu_random_range(
        global_start_hex: str,
        global_end_hex: str,
        min_range_size_str: str,
        max_range_size_str: str,
        used_ranges: Set[str],
        max_saved_random: int
) -> Tuple[Optional[int], Optional[int], Optional[str]]:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Å–ª—É—á–∞–π–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞"""
    try:
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        global_result, error = validate_key_range(global_start_hex, global_end_hex)
        if global_result is None:
            logger.error(f"–û—à–∏–±–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞: {error}")
            return None, None, error

        global_start, global_end, total_keys = global_result

        # –í–∞–ª–∏–¥–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        min_range_size, max_range_size, error = _validate_range_sizes(
            min_range_size_str, max_range_size_str, total_keys
        )
        if error:
            return None, None, error

        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        start_key, end_key = _generate_unique_range(
            global_start, global_end, min_range_size, max_range_size,
            used_ranges, max_saved_random
        )

        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
        range_hash = f"{start_key}-{end_key}"
        used_ranges.add(range_hash)

        return start_key, end_key, None

    except Exception as e:
        error_msg = f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ GPU: {str(e)}"
        logger.exception(error_msg)
        return None, None, error_msg


def _validate_range_sizes(
        min_range_size_str: str,
        max_range_size_str: str,
        total_keys: int
) -> Tuple[int, int, Optional[str]]:
    """–í–∞–ª–∏–¥–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤ –¥–∏–∞–ø–∞–∑–æ–Ω–∞"""
    try:
        min_range_size = int(min_range_size_str)
        max_range_size = int(max_range_size_str)
    except ValueError:
        return 0, 0, "–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —á–∏—Å–ª–∞–º–∏"

    if min_range_size <= 0 or max_range_size <= 0:
        return 0, 0, "–†–∞–∑–º–µ—Ä—ã –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏"

    if min_range_size > total_keys:
        min_range_size = total_keys
    if max_range_size > total_keys:
        max_range_size = total_keys
    if min_range_size > max_range_size:
        min_range_size, max_range_size = max_range_size, min_range_size

    return min_range_size, max_range_size, None


def _generate_unique_range(
        global_start: int,
        global_end: int,
        min_range_size: int,
        max_range_size: int,
        used_ranges: Set[str],
        max_saved_random: int
) -> Tuple[int, int]:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞"""
    range_size = random.randint(min_range_size, max_range_size)
    max_start = global_end - range_size + 1

    if max_start < global_start:
        max_start = global_start

    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
    start_key, end_key = _generate_range_with_retry(
        global_start, max_start, range_size, global_end,
        used_ranges, MAX_RETRY_ATTEMPTS
    )

    return start_key, end_key


def _generate_range_with_retry(
        global_start: int,
        max_start: int,
        range_size: int,
        global_end: int,
        used_ranges: Set[str],
        max_attempts: int
) -> Tuple[int, int]:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
    for _ in range(max_attempts):
        start_key = _generate_random_start_key(global_start, max_start)
        end_key = start_key + range_size - 1

        if end_key > global_end:
            end_key = global_end

        range_hash = f"{start_key}-{end_key}"
        if range_hash not in used_ranges:
            return start_key, end_key

    # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω, –æ—á–∏—â–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é
    if len(used_ranges) >= max_saved_random:
        used_ranges.clear()

    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω
    start_key = _generate_random_start_key(global_start, max_start)
    end_key = min(start_key + range_size - 1, global_end)

    return start_key, end_key


def _generate_random_start_key(global_start: int, max_start: int) -> int:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–π –Ω–∞—á–∞–ª—å–Ω–æ–π —Ç–æ—á–∫–∏"""
    if platform.system() == 'Windows':
        return random.SystemRandom().randint(global_start, max_start)
    else:
        return _generate_secure_random_int(global_start, max_start)


def _generate_secure_random_int(min_val: int, max_val: int) -> int:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞"""
    try:
        with open('/dev/urandom', 'rb') as f:
            rand_bytes = f.read(8)
            rand_val = int.from_bytes(rand_bytes, 'big')
        return min_val + (rand_val % (max_val - min_val + 1))
    except Exception:
        return random.randint(min_val, max_val)


def get_gpu_status(device_id: int = 0) -> Optional[Dict[str, Any]]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å GPU (–∑–∞–≥—Ä—É–∑–∫–∞, –ø–∞–º—è—Ç—å –∏ —Ç.–¥.) —á–µ—Ä–µ–∑ pynvml.
    :param device_id: ID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ GPU (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0)
    :return: dict —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ GPU –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ
    """
    global GPU_STATUS_INITIALIZED

    if not PYNVML_AVAILABLE:
        return None

    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è NVML
        if not GPU_STATUS_INITIALIZED:
            pynvml.nvmlInit()
            GPU_STATUS_INITIALIZED = True

        return _get_gpu_info(device_id)

    except Exception as e:
        logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å GPU {device_id}: {e}")
        return None


def _get_gpu_info(device_id: int) -> Dict[str, Any]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ GPU"""
    handle = pynvml.nvmlDeviceGetHandleByIndex(device_id)

    # –ü–æ–ª—É—á–∞–µ–º —É—Ç–∏–ª–∏–∑–∞—Ü–∏—é
    util_info = pynvml.nvmlDeviceGetUtilizationRates(handle)
    gpu_util = util_info.gpu

    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–∞–º—è—Ç–∏
    mem_info = pynvml.nvmlDeviceGetMemoryInfo(handle)
    mem_used_mb = mem_info.used / (1024 * 1024)
    mem_total_mb = mem_info.total / (1024 * 1024)
    mem_util = (mem_info.used / mem_info.total) * 100 if mem_info.total > 0 else 0

    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É
    temperature = _get_gpu_temperature(handle)

    return {
        'device_id': device_id,
        'gpu_utilization': gpu_util,
        'memory_used_mb': mem_used_mb,
        'memory_total_mb': mem_total_mb,
        'memory_utilization': mem_util,
        'temperature': temperature
    }


def _get_gpu_temperature(handle) -> Optional[int]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã GPU"""
    try:
        return pynvml.nvmlDeviceGetTemperature(handle, pynvml.NVML_TEMPERATURE_GPU)
    except (pynvml.NVMLError, Exception):
        return None